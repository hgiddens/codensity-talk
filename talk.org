* LambdaJam 2014
  - Mark gave stream processing workshop
    - So in a way, this is all his fault.
  - Didn't really get to grips well with pipes during the workshop
  - Tried to understand what the hell was going on
  - Found some documentation and read it
    #+BEGIN_QUOTE
    There are three functions that give polynomial time complexity when used in within pipes:
    - sequence
    - replicateM
    - mapM
    …
    The solution is to use the "codensity transformation" to transform the code to
    run with linear time complexity.
    #+END_QUOTE
* Wat
  #+BEGIN_QUOTE
  The solution is to use the "codensity transformation" to transform the code to
  run with linear time complexity.
  #+END_QUOTE
  #+BEGIN_SRC haskell
    quadratic :: Int -> Consumer a m [a]
    quadratic n = replicateM n await
  
    linear :: Monad m => Int -> Consumer a m [a]
    linear n = lowerCodensity $ replicateM n $ lift await
  #+END_SRC

  This is clearly magic
* /Codensity/ in Scalaz
  - There's a /Codensity/ type in Scalaz
  #+BEGIN_SRC scala
    trait Codensity[F[+_], +A] { self =>
      def apply[B](f: A => F[B]): F[B]
      def improve(implicit F: Applicative[F]): F[A] =
        apply(a => F.point(a))
      def flatMap[B](k: A => Codensity[F, B]): Codensity[F, B] = {
        new Codensity[F, B] {
          def apply[C](h: B => F[C]): F[C] = 
            self.apply(a => k(a)(h))
        }
      }
    }
  #+END_SRC
  - I had no idea what this did
* Asymptotic Improvement of Computations over Free Monads
  - A paper by Janis Voigtländer
  #+BEGIN_QUOTE
  Not only do monads allow [us] to safely encapsulate impure features of the
  programming language, but they are also used in pure code to separate
  concerns and provide modular design. But, as usual in software construction,
  modularity comes at a cost, typically with respect to program efficiency. We
  propose a method to improve the efficiency of code over a large variety of
  monads. A distinctive feature is that this method is non-intrusive: it
  preserves the appearance of code, with the obvious software engineering
  benefits.
  #+END_QUOTE
  - This sounds promising!
  - Paper has a nice simple example of the approach, using balanced binary trees
* A /Tree/ type
  - A simple, boring, binary tree data type
  #+BEGIN_SRC scala
    sealed trait Tree[A]
    case class Leaf[A](a: A) extends Tree[A]
    case class Node[A](l: Tree[A], r: Tree[A]) extends Tree[A]
  #+END_SRC
  - With a monad instance, where /bind/ runs a function over the leaf nodes
  #+BEGIN_SRC scala
    implicit object treeMonad extends Monad[Tree] {
      def point[A](a: => A): Tree[A] = Leaf(a)
      def bind[A, B](fa: Tree[A])(f: A => Tree[B]) = fa match {
        case Leaf(a) => f(a)
        case Node(l, r) => Node(bind(l)(f), bind(r)(f))
      }
    }
  #+END_SRC
* A function to generate trees
  #+BEGIN_SRC scala
    def fullTree(i: Int): Tree[Int] = i match {
      case 1 => Leaf(1)
      case n =>
        val j = n - 1
        fullTree(j).flatMap { t =>
          Node(Leaf(j - t), Leaf(t + 1))
        }
    }
  #+END_SRC

  This function will generate trees of the following form:
  #+BEGIN_SRC scala
    Leaf(1) // i = 1
    Node(
      Leaf(0), Leaf(2)) // i = 2
    Node(
      Node(
        Leaf(2), Leaf(1)),
      Node(
        Leaf(0), Leaf(3))) // i = 3
    // And so on
  #+END_SRC
* The thing about creating trees with 2^n nodes
  - It turns out that, given a large n, it can take quite a while to create a tree with 2^n nodes.
  - The Haskell examples in the paper don't exhibit this problem due to lazy evaluation
  - We can use call-by-name to fix this
** We had
   #+BEGIN_SRC scala
     case class Node[A](l: Tree[A], r: Tree[A]) extends Tree[A]
   #+END_SRC
** We'll instead use
   #+BEGIN_SRC scala
     class Node[A](_l: => Tree[A], _r: => Tree[A]) extends Tree[A] {
       lazy val l = _l
       lazy val r = _r
     }
   #+END_SRC
* And some function to traverse them
  #+BEGIN_SRC scala
    def zigzag(tree: Tree[Int]): Int = {
      def zig(t: Tree[Int]): Int = t match {
        case Leaf(n) => n
        case n: Node[Int] => zag(n.l)
      }
      def zag(t: Tree[Int]): Int = t match {
        case Leaf(n) => n
        case n: Node[Int] => zig(n.r)
      }
      zig(tree)
    }
  #+END_SRC
* And how does it perform?
  - /zigzag/, for a tree of depth n, needs to look at n nodes
  - and /fullTree/ is constructing things lazily for us
  - so of course, calling /zigzag(fullTree(n))/ our performance is…
* And how does it perform?
  - /zigzag/, for a tree of depth n, needs to look at n nodes
  - and /fullTree/ is constructing things lazily for us
  - so of course, calling /zigzag(fullTree(n))/ our performance is… polynomial.
  [[./tmp/quad-small.png]]
* SAD TROMBONE NOISE
  - The cost is in building the tree
  - But not due to its final size
  - It's due instead to the repeated creation and destruction of the intermediate trees
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(1))
      = zigzag(Leaf(1)) // 1 leaf
  #+END_SRC

* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(2))
      = zigzag(fullTree(1).flatMap(fn))
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(2))
      = zigzag(fullTree(1).flatMap(fn))
      = zigzag(Leaf(1).flatMap(fn)) // 1 leaf
  #+END_SRC

* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(2))
      = zigzag(fullTree(1).flatMap(fn))
      = zigzag(Leaf(1).flatMap(fn)) // 1 leaf
      = zigzag(Node(<thunk>, <thunk>)) // 1 node
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(2))
      = zigzag(fullTree(1).flatMap(fn))
      = zigzag(Leaf(1).flatMap(fn)) // 1 leaf
      = zigzag(Node(<thunk>, <thunk>)) // 1 node
      = zigzag(Node(Leaf(0), <thunk>)) // 1 leaf
      = 0 // Total of 1 node and two leaves allocated
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
      = zigzag(Node(<thunk>, <thunk>).flatMap(fn)) // 1 leaf, 1 node (from fullTree(2))
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
      = zigzag(Node(<thunk>, <thunk>).flatMap(fn)) // 1 leaf, 1 node (from fullTree(2))
      = zigzag(Node(Leaf(0).flatMap(fn), <thunk>)) // 1 leaf
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
      = zigzag(Node(<thunk>, <thunk>).flatMap(fn)) // 1 leaf, 1 node (from fullTree(2))
      = zigzag(Node(Leaf(0).flatMap(fn), <thunk>)) // 1 leaf
      = zigzag(Node(Node(<thunk>, <thunk>))) // 2 nodes
  #+END_SRC
* Consider the sequence of calls here
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
      = zigzag(Node(<thunk>, <thunk>).flatMap(fn)) // 1 leaf, 1 node (from fullTree(2))
      = zigzag(Node(Leaf(0).flatMap(fn), <thunk>)) // 1 leaf
      = zigzag(Node(Node(<thunk>, <thunk>))) // 2 nodes
      = zigzag(Node(Node(<thunk>, Leaf(1)))) // 1 leaf
      = 1 // Total of 3 nodes and 3 leaves allocated
  #+END_SRC

  And so on; for a tree of depth n, /fullTree/ will create (n^2 - n)/2 nodes and n leaves.
* So how can we use Codensity to help us?
  - Uses a typeclass to provide the ‘make a node’ operation
    #+BEGIN_SRC scala
      trait TreeLike[F[_]] {
        def node[A](l: => F[A], r: => F[A]): F[A]
      }
      
      implicit object treeTreeLike extends TreeLike[Tree] {
        def node[A](l: => Tree[A], r: => Tree[A]): Tree[A] =
          new Node(l, r)
      }
    #+END_SRC
* So how can we use Codensity to help us?
  - Using our new type class, make /fullTree/ generate a full tree of some
    abstract type
    #+BEGIN_SRC scala
      def fullTree[F[_]: Monad](i: Int)(implicit FT: TreeLike[F]): F[Int] =
        i match {
          case 1 => 1.point[F]
          case n =>
            val j = n - 1
            fullTree[F](j).flatMap { t =>
              FT.node((j - 1).point[F], (j + 1).point[F])
            }
        }
      
    #+END_SRC
  - A quick test here demonstrates that /zigzag(fullTree[Tree](n))/ still
    behaves polynomialally
* So how can we use Codensity to help us?
  - Make a type alias for our /Codensity/-using tree
    #+BEGIN_SRC scala
      type CodensityTree[A] = Codensity[Tree, A]
    #+END_SRC
  - Define a /TreeLike/ instance for /CodensityTree/
    #+BEGIN_SRC scala
      implicit object codensityTreeTreeLike extends TreeLike[CodensityTree] {
        def node[A](l: => CodensityTree[A], r: => CodensityTree[A]): CodensityTree[A] =
          new Codensity[Tree, A] {
            def apply[B](f: A => Tree[B]) =
              new Node(l.apply(f), r.apply(f))
          }
      }
    #+END_SRC
* So how can we use Codensity to help us?
  - Now, we can call /fullTree[CodensityTree](n)/, and get a
    /Codensity[Tree, Int]/ back
  - But /zigzag/ needs one of our original /Tree[Int]/ values.
  - Time for the promisingly named method /improve/:
    #+BEGIN_SRC scala
    trait Codensity[F[_], A] {
      def improve(implicit F: Applicative[F]): F[A] =
        apply(a => F.point(a))
    #+END_SRC
  - And when we run /zigzag(fullTree[CodensityTree](n).improve)/ …
* So how can we use Codensity to help us?
  - Now, we can call /fullTree[CodensityTree](n)/, and get a
    /Codensity[Tree, Int]/ back
  - But /zigzag/ needs one of our original /Tree[Int]/ values.
  - Time for the promisingly named method /improve/:
    #+BEGIN_SRC scala
    trait Codensity[F[_], A] {
      def improve(implicit F: Applicative[F]): F[A] =
        apply(a => F.point(a))
    #+END_SRC
  - And when we run /zigzag(fullTree[CodensityTree](n).improve)/ we see that
    we do, indeed, get linear performance:
    [[./tmp/linear-small.png]]
* So how can we use Codensity to help us
  As promised, we didn't have to change the implementation of /fullTree/ (after we'd made it generic in the type of tree that it constructs). The constant factors are ok too:
  [[./tmp/all-small.png]]
* How does this work?
  Recall how /zigzag(fullTree[Tree](3))/ expanded as the following
  #+BEGIN_SRC scala
    val fn: Int => Tree[Int] = i => Node(Leaf(i - 1), Leaf(i + 1))
    
    zigzag(fullTree(3))
      = zigzag(fullTree(2).flatMap(fn))
      = zigzag(Node(<thunk>, <thunk>).flatMap(fn)) // 1 leaf, 1 node (from fullTree(2))
      = zigzag(Node(Leaf(0).flatMap(fn), <thunk>)) // 1 leaf
      = zigzag(Node(Node(<thunk>, <thunk>))) // 2 nodes
      = zigzag(Node(Node(<thunk>, Leaf(1)))) // 1 leaf
      = 1 // Total of 3 nodes and 3 leaves allocated
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    val fn: Int => CodensityTree[Int] = { i =>
      codensityTreeTreeLike.node(
        (i - 1).point[CodensityTree],
        (i + 1).point[CodensityTree])
    }
    
    zigzag(fullTree[CodensityTree](1).improve)
      = zigzag(new Codensity[Tree, Int] {
        def apply[B](f: Int => Tree[B]) = f(1)
      }.improve) // 1 codensitytree
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    val fn: Int => CodensityTree[Int] = { i =>
      codensityTreeTreeLike.node(
        (i - 1).point[CodensityTree],
        (i + 1).point[CodensityTree])
    }
    
    zigzag(fullTree[CodensityTree](1).improve)
      = zigzag(new Codensity[Tree, Int] {
        def apply[B](f: Int => Tree[B]) = f(1)
      }.improve) // 1 codensitytree
      = zigzag(new Codensity[Tree, Int] {
        def apply[B](f: Int => Tree[B]) = f(1)
      }.apply(Leaf(_)))
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    val fn: Int => CodensityTree[Int] = { i =>
      codensityTreeTreeLike.node(
        (i - 1).point[CodensityTree],
        (i + 1).point[CodensityTree])
    }
    
    zigzag(fullTree[CodensityTree](1).improve)
      = zigzag(new Codensity[Tree, Int] {
        def apply[B](f: Int => Tree[B]) = f(1)
      }.improve) // 1 codensitytree
      = zigzag(new Codensity[Tree, Int] {
        def apply[B](f: Int => Tree[B]) = f(1)
      }.apply(Leaf(_)))
      = zigzag(Leaf(1)) // 1 leaf
      = 1 // Total of 1 CodensityTree and 1 Leaf
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
      // Tree built; run improve
      = zigzag(fullTree(1).apply(a => fn(a)(Leaf(_))))
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
      // Tree built; run improve
      = zigzag(fullTree(1).apply(a => fn(a)(Leaf(_))))
      = zigzag(fn(1)(Leaf(_)))
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
      // Tree built; run improve
      = zigzag(fullTree(1).apply(a => fn(a)(Leaf(_))))
      = zigzag(fn(1)(Leaf(_)))
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   new Node(<thunk>.apply(f), <thunk>)
               }.apply(Leaf(_))) // 1 CodensityTree
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
      // Tree built; run improve
      = zigzag(fullTree(1).apply(a => fn(a)(Leaf(_))))
      = zigzag(fn(1)(Leaf(_)))
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   new Node(<thunk>.apply(f), <thunk>)
               }.apply(Leaf(_))) // 1 CodensityTree
      = zigzag(new Node(new Codensity[Tree, Int] {
                          def apply[B](f: Int => Tree[B]) = f(0)
                        }.apply(Leaf(_)), <thunk>)) // 1 CodensityTree, 1 Node
  #+END_SRC
* Call expansion for /CodensityTree/
  #+BEGIN_SRC scala
    zigzag(fullTree[CodensityTree](2).improve)
      = zigzag(fullTree(1).flatMap(fn).improve) // 1 CodensityTree
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   fullTree(1).apply(a => fn(a)(f))
               }.improve) // 1 CodensityTree
      // Tree built; run improve
      = zigzag(fullTree(1).apply(a => fn(a)(Leaf(_))))
      = zigzag(fn(1)(Leaf(_)))
      = zigzag(new Codensity[Tree, Int] {
                 def apply[B](f: Int => Tree[B]) =
                   new Node(<thunk>.apply(f), <thunk>)
               }.apply(Leaf(_))) // 1 CodensityTree
      = zigzag(new Node(new Codensity[Tree, Int] {
                          def apply[B](f: Int => Tree[B]) = f(0)
                        }.apply(Leaf(_)), <thunk>)) // 1 CodensityTree, 1 Node
      = zigzag(new Node(Leaf(0), <thunk>))
      = 0 // 3 CodensityTrees, 1 Node, and 1 Leaf allocated
  #+END_SRC
* Call expansion for /CodensityTree/
  In general
  - to build a /CodensityTree/ of depth n:
    n /CodensityTree/ instances
  - to subsequently run /zigzag(t.improve)/
    n /CodensityTree/ instances
    (n - 1) /Node/ instances
    1 /Leaf/ instance
* Makes binds right-associative
  - One consequence of using /Codensity/ is that it makes binds right associative
  - For example
    #+BEGIN_SRC scala
      // ‘Left associative binds’ are easier to write, but here creates and destroys
      // intermediate data structures unnecessarily:
      List(1,2).flatMap(fn_a).flatMap(fn_b)
      
      // Right associative binds are a little easier on the garbage collector, but a
      // little less pleasant to write:
      List(1,2).flatMap(x => fn_a(x).flatMap(fn_b))
      
      // This performs the binds in the right associative fashion as with the second
      // example above without requiring the binds be written right-associatively
      Codensity.rep(List(1,2)).flatMap(fn_a).flatMap(fn_b).improve
    #+END_SRC
  - This is a safe transformation thanks to the monad laws!
  - So can create problems for ‘monads’ that don't follow them e.g. /ListT/
    in Haskell.
* fmap fusion
  #+BEGIN_SRC scala
    // Similarly to bind, repeated map calls can also lead to the excessive
    // creation and destruction of intermediate data structures.
    //
    // After each map call here an intermediate list is generated only to shortly
    // become garbage.
    List(1,2).map(foo).map(bar).map(baz)
    
    // This can be avoided by composing the functions:
    List(1,2).map(foo.map(bar).map(baz))
    
    // Codensity ‘fuses’ the mapped functions together, such that this behaves as
    // the example above.
    Codensity.rep(List(1,2)).map(foo).map(bar).map(baz).improve
  #+END_SRC
  
  - Use this to create a /Functor[Codensity[Set, _]]/ and amuse and/or dismay
    your friends!
  - This can also achieved via the simpler[[[a][citation needed]]] Yoneda lemma
* Real world examples
  - As hinted at by the title of the paper, this can be especially helpful
    with code that makes heavy use of the free monad
  - Haskell's pipes library uses this to avoid polynomial space growth when
    buiding lists from streams
  - BONUS ROUND: All this can apparently be achieved using only Yoneda but
    sometimes when I close my eyes I still see the compiler errors.
* Links
  - Asymptotic Improvement of Computations over Free Monads, by Janis Voigtländer
    http://www.iai.uni-bonn.de/~jv/mpc08.pdf
  - Ed Kmett has a blog series about this, starting with ‘Free Monads for less’. Good luck!
    http://comonad.com/reader/2011/free-monads-for-less/
  - This will theoretically be pushed to Bitbucket at some point.
    https://bitbucket.org/hgiddens/codensity-talk
